#Most of the code was generated by DeepSeek V3 between 11/25/2025 - 12/07/2025
import pandas as pd
import numpy as np
import streamlit as st
import matplotlib.pyplot as plt
import seaborn as sns
from datasource import *

st.set_page_config(page_title="Data Processing & Feature Engineering", page_icon="*")

st.title("Data Processing & Feature Engineering")
st.markdown("This page demonstrates key feature engineering techniques for enhancing predictive modeling.")

# Load data
df_heart = load_and_clean()
df_country = load_country()
df_indicators = load_indicators()

# =============================================================================
# SECTION 1: BINNING & DISCRETIZATION
# =============================================================================

st.header("Binning & Discretization")

st.write("""
We perform this step during model preparation because it simplifies continuous variables into a smaller number of categories.
Certain machine-learning algorithms can detect patterns more easily this way, especially if we have multiple features and non-linear relationships.
We can also reduce the impact of noise in the raw data, and improve stability by preventing overly specific splits. 

Additionally, binning allows us to greatly reduce the impact of extreme outliers.
         """)
# Binning for Age
st.subheader("Age Binning")
st.write("""With respec to the heart disease analysis, it makes sense to slits age into four bins:
         
         - Young (0 to 35)
         - Middle (36-50)
         - Senior (51-65)
         - Elderly (66+)
         """)

if 'Age' in df_heart.columns:
    # Create age bins
    df_heart['Age_bin'] = pd.cut(df_heart['Age'], 
                                bins=[0, 35, 50, 65, 100], 
                                labels=['Young (â‰¤35)', 'Middle (36-50)', 'Senior (51-65)', 'Elderly (66+)'])
    
    # Show distribution
    col1, col2 = st.columns(2)
    
    with col1:
        fig, ax = plt.subplots(figsize=(10, 4))
        df_heart['Age_bin'].value_counts().sort_index().plot(kind='bar', ax=ax, color='skyblue')
        ax.set_title('Age Bin Distribution')
        ax.set_xlabel('Age Category')
        ax.set_ylabel('Count')
        plt.xticks(rotation=45)
        st.pyplot(fig)
    
    with col2:
        # Calculate heart disease rates by age bin
        age_rates = df_heart.groupby('Age_bin')['Heart Disease Status'].apply(
            lambda x: (x == 'Yes').mean() * 100
        ).round(2)
        
        st.write("**Heart Disease Prevalence by Age Group:**")
        st.dataframe(age_rates.rename('Heart Disease %'))
        
        fig, ax = plt.subplots(figsize=(10, 4))
        age_rates.plot(kind='bar', ax=ax, color='coral')
        ax.set_title('Heart Disease % by Age Group')
        ax.set_xlabel('Age Category')
        ax.set_ylabel('Heart Disease %')
        plt.xticks(rotation=45)
        st.pyplot(fig)

# Binning for BMI
st.subheader("BMI Categorization")
st.write(""" 
         For age, standard BMI metrics will be applied:
         
         - Underweight (below 18.5)
         - Normal (18.5 to 25)
         - Overweight (25 to 30)
         - Obese (over 30)
         """)
if 'BMI' in df_heart.columns:
    # Create BMI categories
    df_heart['BMI_category'] = pd.cut(df_heart['BMI'], 
                                     bins=[0, 18.5, 25, 30, 100],
                                     labels=['Underweight', 'Normal', 'Overweight', 'Obese'])
    
    # Show distribution
    col1, col2 = st.columns(2)
    
    with col1:
        fig, ax = plt.subplots(figsize=(10, 4))
        df_heart['BMI_category'].value_counts().sort_index().plot(kind='bar', ax=ax, color='lightgreen')
        ax.set_title('BMI Category Distribution')
        ax.set_xlabel('BMI Category')
        ax.set_ylabel('Count')
        plt.xticks(rotation=45)
        st.pyplot(fig)
    
    with col2:
        # Calculate heart disease rates by BMI category
        bmi_rates = df_heart.groupby('BMI_category')['Heart Disease Status'].apply(
            lambda x: (x == 'Yes').mean() * 100
        ).round(2)
        
        st.write("**Heart Disease Prevalence by BMI Category:**")
        st.dataframe(bmi_rates.rename('Heart Disease %'))
        
        fig, ax = plt.subplots(figsize=(10, 4))
        bmi_rates.plot(kind='bar', ax=ax, color='orange')
        ax.set_title('Heart Disease % by BMI Category')
        ax.set_xlabel('BMI Category')
        ax.set_ylabel('Heart Disease %')
        plt.xticks(rotation=45)
        st.pyplot(fig)

# Binning for Blood Pressure
st.subheader("Blood Pressure Binning")
st.write("""
         For Blood Pressure, the bins are the following:
         
         - Normal (less than 120)
         - Elevated (120 to 130)
         - Stage 1 (130 to 140)
         - Stage 2 (140 to 180)
         - Crisis (over 180)
         """)
if 'Blood Pressure' in df_heart.columns:
    # Create BP categories
    df_heart['BP_category'] = pd.cut(df_heart['Blood Pressure'],
                                    bins=[0, 120, 130, 140, 180, 300],
                                    labels=['Normal', 'Elevated', 'Stage 1', 'Stage 2', 'Crisis'])
    
    # Show distribution
    col1, col2 = st.columns(2)
    
    with col1:
        fig, ax = plt.subplots(figsize=(10, 4))
        df_heart['BP_category'].value_counts().sort_index().plot(kind='bar', ax=ax, color='salmon')
        ax.set_title('Blood Pressure Category Distribution')
        ax.set_xlabel('BP Category')
        ax.set_ylabel('Count')
        plt.xticks(rotation=45)
        st.pyplot(fig)
    
    with col2:
        # Calculate heart disease rates by BP category
        bp_rates = df_heart.groupby('BP_category')['Heart Disease Status'].apply(
            lambda x: (x == 'Yes').mean() * 100
        ).round(2)
        
        st.write("**Heart Disease Prevalence by Blood Pressure:**")
        st.dataframe(bp_rates.rename('Heart Disease %'))
        
        fig, ax = plt.subplots(figsize=(10, 4))
        bp_rates.plot(kind='bar', ax=ax, color='purple')
        ax.set_title('Heart Disease % by Blood Pressure')
        ax.set_xlabel('BP Category')
        ax.set_ylabel('Heart Disease %')
        plt.xticks(rotation=45)
        st.pyplot(fig)

# Binning Summary
st.subheader("Summary & Removing Outliers from Binning")
st.write("""As can be seen in the table below, nearly all values were binned successfully. Extreme outliers that do not represent real-world
         range of health parameters, such as obnormally high age, BMI, blood pressure, are removed.
         """)
if any(col in df_heart.columns for col in ['Age_bin', 'BMI_category', 'BP_category']):
    binning_cols = [col for col in ['Age_bin', 'BMI_category', 'BP_category'] if col in df_heart.columns]
    
    summary_data = []
    for col in binning_cols:
        summary_data.append({
            'Feature': col.replace('_', ' ').title(),
            'Categories': df_heart[col].nunique(),
            'Non-Null Count': df_heart[col].count(),
            'Missing Values': df_heart[col].isnull().sum()
        })
    
    st.dataframe(pd.DataFrame(summary_data))

# =============================================================================
# SECTION 2: PCA - DIMENSIONALITY REDUCTION
# =============================================================================

st.header("Principal Component Analysis (PCA)")

# Select socioeconomic indicators for PCA
socioecon_indicators = ['GDP', 'Life expectancy', 'Physicians per thousand', 
                       'Urban_population', 'Infant mortality']
available_indicators = [ind for ind in socioecon_indicators if ind in df_indicators.columns]

if len(available_indicators) > 1:
    st.subheader("Selected Features for PCA from the third dataset (socioeconomic indicators)")
    st.write(f"Using {len(available_indicators)} socioeconomic indicators:")
    
    # Show statistics of selected features
    stats_df = df_indicators[available_indicators].describe().round(3)
    st.dataframe(stats_df)
    
    # Correlation matrix
    st.write("The correlation matrix is the following:")
    corr_matrix = df_indicators[available_indicators].corr()
    
    fig, ax = plt.subplots(figsize=(8, 6))
    sns.heatmap(corr_matrix, annot=True, cmap='coolwarm', center=0, 
                square=True, linewidths=1, ax=ax)
    ax.set_title('Correlation Matrix of Socioeconomic Indicators')
    st.pyplot(fig)
    
    # Perform PCA
    st.subheader("PCA Implementation")
    
    from sklearn.decomposition import PCA
    from sklearn.preprocessing import StandardScaler
    
    # Prepare data
    X = df_indicators[available_indicators].dropna()
    
    if len(X) > 0:
        # Standardize the data
        scaler = StandardScaler()
        X_scaled = scaler.fit_transform(X)
        
        # Perform PCA
        pca = PCA(n_components=min(3, len(available_indicators)))
        principal_components = pca.fit_transform(X_scaled)
        
        # Create results DataFrame
        df_pca = pd.DataFrame(data=principal_components, 
                            columns=[f'PC{i+1}' for i in range(principal_components.shape[1])],
                            index=X.index)
        
        # Add back country names
        df_pca['Country'] = df_indicators.loc[X.index, 'Country']
        
        # Show PCA results
        st.write(f"**Explained Variance Ratio:** {pca.explained_variance_ratio_.round(3)}")
        st.write(f"**Total Variance Explained:** {sum(pca.explained_variance_ratio_):.3f}")
        
        # Component loadings
        st.write("**PCA Component Loadings:**")
        loadings_df = pd.DataFrame(
            pca.components_.T,
            columns=[f'PC{i+1}' for i in range(pca.n_components_)],
            index=available_indicators
        )
        st.dataframe(loadings_df.round(3))
        
        # Visualize PCA
        st.subheader("Visualization")
        
        col1, col2 = st.columns(2)
        
        
        # Scree plot
        fig, ax = plt.subplots(figsize=(8, 4))
        ax.bar(range(1, len(pca.explained_variance_ratio_) + 1), 
                pca.explained_variance_ratio_, 
                color='steelblue', alpha=0.7)
        ax.plot(range(1, len(pca.explained_variance_ratio_) + 1), 
                np.cumsum(pca.explained_variance_ratio_), 
                marker='o', color='coral', linewidth=2)
        ax.set_xlabel('Principal Component')
        ax.set_ylabel('Explained Variance Ratio')
        ax.set_title('Scree Plot: PCA Explained Variance')
        ax.legend(['Cumulative', 'Individual'])
        ax.grid(True, alpha=0.3)
        st.pyplot(fig)
        
        
        # Biplot (PC1 vs PC2)
        if pca.n_components_ >= 2:
            fig, ax = plt.subplots(figsize=(8, 6))
            
            # Plot data points
            scatter = ax.scatter(df_pca['PC1'], df_pca['PC2'], 
                                alpha=0.6, s=50, edgecolors='w', linewidth=0.5)
            
            # Plot feature vectors
            for i, feature in enumerate(available_indicators):
                ax.arrow(0, 0, pca.components_[0, i]*3, pca.components_[1, i]*3,
                        head_width=0.1, head_length=0.1, fc='red', ec='red', alpha=0.7)
                ax.text(pca.components_[0, i]*3.2, pca.components_[1, i]*3.2,
                        feature, color='red', fontsize=9)
            
            ax.set_xlabel(f'PC1 ({pca.explained_variance_ratio_[0]*100:.1f}% variance)')
            ax.set_ylabel(f'PC2 ({pca.explained_variance_ratio_[1]*100:.1f}% variance)')
            ax.set_title('PCA Biplot: PC1 vs PC2')
            ax.grid(True, alpha=0.3)
            ax.axhline(y=0, color='k', linestyle='--', alpha=0.3)
            ax.axvline(x=0, color='k', linestyle='--', alpha=0.3)
            st.pyplot(fig)
        
        # Show countries with extreme PCA scores
        st.subheader("2.6 Countries with Extreme PCA Scores")
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.write("**Countries with Highest PC1 Scores:**")
            top_pc1 = df_pca.nlargest(5, 'PC1')[['Country', 'PC1']]
            st.dataframe(top_pc1.round(3))
        
        with col2:
            st.write("**Countries with Lowest PC1 Scores:**")
            bottom_pc1 = df_pca.nsmallest(5, 'PC1')[['Country', 'PC1']]
            st.dataframe(bottom_pc1.round(3))
        
        # Interpretation
        
else:
    st.warning("Insufficient socioeconomic indicators available for PCA")

